import pandas as pd
import sys
import pathlib as pl
import tkinter as tk
from tkinter import filedialog
from tkinter.ttk import Treeview
from tkinter import ttk

background_color_main='#262624'
text_color="#E9E9E9"
button_backg_color="#30302E"
module_level={}

class CycloMeter():
    '''Object that reads Strava CSV file. Due to Strava using meter/per second convention,
    object directly overwrites nonintuitive conventions to metric system.'''
    def __init__(self, path):
        self.pathAssign(path)
        self.msToKM('average speed')
        self.msToKM('max speed')
        self.secsToHour('moving time')
        self.condition=None
        self.sort_column = None
        self.sort_ascending = True

    def pathAssign(self, path: str):
        '''Assign path to user selected dir'''
        path = pl.Path(path)
        try:
            df = pd.read_csv(path)
        except Exception as e:
            raise IOError(f"Failed to read CSV: {e}") from e
        df.columns = [c.lower() for c in df.columns]
        self.data = df.copy()   # keep copy
        return self
    
    def sortValues(self, column):
        '''Sort columns when clicked'''
        if self.sort_column==column:
            self.sort_ascending=not self.sort_ascending
        else:
            self.sort_ascending=True
        
        self.sort_column=column
        self.data = self.data.sort_values(by=column, ascending=self.sort_ascending)
    
    def setCondition(self, condition):
        '''Condition property for filterization'''
        if condition is None:
            self.condition=None
        else:
            self.condition=condition
    
    def filterResults(self, column: str, operator: str, value: float, reset: bool):
        '''Filter results logic'''
        try:value=float(value)
        except:
            print('Value error, please enter valid characters.')
            return False
        if reset:
            condition=None
            pass
        elif operator == ">":
            condition=self.data[column]>value
        elif operator == "<":
            condition=self.data[column]<value
        elif operator == "<=":
            condition=self.data[column]<=value
        elif operator == ">=":
            condition=self.data[column]>=value
        elif operator == "==":
            condition=self.data[column]==value
        else:
            print('Invalid operation.')
            return False
        #Feedback to CLI/GUI
        if condition is None:print('Filter is removed, insert table for default view.')
        else:print('Filterization is complete!')
        self.setCondition(condition)
        return True
    
    def extractColumn(self, column:str):
        'return column, mutates self.data obj'
        column=column.lower()
        if column in self.data.columns:
            return self.data[f"{column}"]
        else:
            raise KeyError("Column not found.")

    def extractMultiColumns(self, column:list):
        'Takes list with items as column str'

        return self.data[column]

    def msToKM(self, column:str):
        'Convert from meter/second to kph'
        col = column.lower()
        if col not in self.data.columns:
            raise KeyError(col)
        self.data = self.data.assign(**{f"{col} kmh": (self.data[col].astype(float) * 3.6).round(2)})

    def secsToHour(self, column):
        'convert speed format to kmh'
        if column in self.data.columns:
            meter=self.extractColumn(column)
            meter=meter/3600
            meter=round(meter, 3)
            self.data[f"{column}/h"]=meter

class TextRedirector():
    '''displays cmd line on GUI via sys.stdout is calling write. (Python auto calls write functions at any time in need of display or write an output)'''
    def __init__(self, text_widget:tk.Text, delay=40):
        self.text_widget = text_widget
        self.delay = delay
        self.text = ""
        self.index = 0

    def write(self,text):
        'Insert a single char'
        if self.index == 0:
            self.text_widget.configure(state='normal')
            self.text_widget.delete("1.0", "end")
            self.text_widget.configure(state='disabled')
            self.text = text
            self.insertNextChar()

    def insertNextChar(self):
        if self.index < len(self.text):
            char = self.text[self.index]
            self.text_widget.configure(state='normal')
            self.text_widget.insert("end", char)
            self.text_widget.see("end")
            self.text_widget.configure(state='disabled')
            self.index += 1
            self.text_widget.after(self.delay, self.insertNextChar)
        else:
            self.index = 0

    def flush(self):
        pass

class EntryField():
    def __init__(self, parent:tk.Tk, text:str):
        self.frame=tk.Frame(parent)
        self.entry=tk.Entry(self.frame)
        self.text=text
        self.label=tk.Label(self.frame, text=self.text)
    
    def packButtonHelper(self):
        'pack the called entry'
        self.entry.pack(side=tk.RIGHT)
        self.label.pack(side=tk.LEFT)
        self.frame.pack(side="top")

class ButtonField():
    def __init__(self, parent:tk.Tk, text:str):
        self.frame=tk.Frame(parent)
        self.entry=tk.Button(self.frame, text=text)
    
    def packButtonHelper(self):
        'pack the called button'
        self.entry.pack()
        self.frame.pack(side="top")

def loadFile():
    'open .csv file and append items as valid columns'
    items=['activity id', 'activity date', 'moving time/h', 'distance', 'max heart rate', 'average heart rate', 'average speed kmh', 'max speed kmh', 'average watts', 'calories'] 
    path=filedialog.askopenfilename()

    if path:
        cyclingObj=CycloMeter(path)
        cyclingObj.data=cyclingObj.data[items]
        module_level['obj']=cyclingObj
    else:
        pass
    return cyclingObj

def displayData(cyclingObj:CycloMeter):
    'copying current data, and displaying based on the filterization'
    if cyclingObj.condition is not None: #If data is filtered, adjust the view.
        display_data:pd.Dataframe=cyclingObj.data[cyclingObj.condition]
    else: #Unfiltered, raw data copy.
        display_data:pd.Dataframe=cyclingObj.data #iterate dataframe records and get Series
    return display_data

def displayHelp():
    text="To filter results, add a valid column, operator (>,<,>=,<=,==), and a value.\nTo remove filter, click X button."
    print(text)

def updateStatusBar(status_bar:tk.Text):
    'reroute sys print statements to TextRedirector object'
    sys.stdout=TextRedirector(status_bar)

def treeview_init(tree_view:Treeview, display_data, pandasGenerator, cyclingObj:CycloMeter):
    '''Adjust, insert and clear'''

    for t in tree_view.get_children(): tree_view.delete(t)

    #A bit complex but briefly, when clicked calls on sortedValues then 
    # insertTable again, sortedValues directly mutates the self.data then 
    # insertedtable just normally calls on that object with mutated data etc
    for i in list(display_data.columns): 
        tree_view.heading(i, text=i, command=lambda col=i: (cyclingObj.sortValues(col), insertTable(tree_view, cyclingObj))) 
        tree_view.column(i, width=180) #column sorting
    
    for index, value in pandasGenerator: #Iterating through panda rows
        raw_values=value.values #Series obj (bool T/F) to raw values
        tree_view.insert('','end',values=raw_values.tolist()) #''(start) to end insertion of columns not records
    print(f"Table insertion is complete!") #debugging needs removed on scaffolding

def insertTable(tree_view, cyclingObj:CycloMeter):
    'insert table with filtered or unfiltered results packed, and initialize treeView.'
    display_data=displayData(cyclingObj)
    tree_view['columns']=list(display_data.columns) #update tree_view obj
    tree_view.column('#0', width=0, stretch=False)
    pandasRows=display_data.iterrows() #iterate dataframe records and get Series
    treeview_init(tree_view, display_data, pandasRows, cyclingObj)

def retrieveEntry(column_name:tk.Entry,op:tk.Entry,setVal:tk.Entry, cyclingObj:CycloMeter, reset=False):
    '''return input of textBox'''
    column_name=column_name.get()
    operator=op.get()
    val=setVal.get()
    cyclingObj.filterResults(column_name,operator,val, reset)
    
def packTextButtonHelper(window):
    'user status bar packing'
    status_bar_frame=tk.Frame(window)
    status_bar=tk.Text(status_bar_frame, state='disabled', height=3, width=57)
    return status_bar, status_bar_frame

def initEntryBoxes(window, label_names:list):
    '''label_names: list with strings that matches lenght of count
       
       Creates len label_names number of entry buttons and returns list of all entry buttons'''
    items=[]
    for i in label_names:
        entry_field=EntryField(window,i)
        items.append(entry_field)
    return items

def initStatusBar(window):
    'user status bar initialization'
    status_bar_tuple=packTextButtonHelper(window)
    updateStatusBar(status_bar_tuple[0])
    displayHelp()
    return status_bar_tuple

def initButtonsConfig(tree_view, input_boxes:list, window):
    """Dict style configurations to pass on initButtons function
    
    Returns button configuration for the main window."""

    column_field, operator_field, value_field=input_boxes
    button_config=[
        {
            "parent": window,
            "type": "single",
            "text": "Load CSV File",
            "command": loadFile
        },
        {
            "parent": window,
            "type": "single",
            "text": "Insert Table",
            "command": lambda:insertTable(tree_view, module_level['obj'])
        },
        {
            "parent": window,
            "type": "group",
            "buttons":[
                {
                    "text": "Filter", "command": lambda:retrieveEntry(column_field.entry,operator_field.entry,value_field.entry, module_level['obj'], reset=False)},
                {
                    "text": "X", "command": lambda:retrieveEntry(column_field.entry,operator_field.entry,value_field.entry, module_level['obj'], reset=True)}]
        }
    ]
    return button_config

def initButtons(button_config):
    'pack buttons and the frames in applicable groups'
    for config in button_config:
        if config["type"] == "single":
            button=tk.Button(config["parent"], 
                             text=config["text"], 
                             command=config["command"])
            button.pack()
        elif config["type"] == "group":
            frame_filter=tk.Frame(config["parent"])
            for button_cfg in config["buttons"]:
                buttons_filter=tk.Button(frame_filter, 
                                         text=button_cfg["text"], 
                                         command=button_cfg["command"]) #text box
                buttons_filter.pack(side='left')
            frame_filter.pack()

def applyStyle(window:tk.Tk):
    'GUI style application via nested dicts'
    style=ttk.Style(master=window)
    window.option_add('*Text.font', ('Segoe UI', 12))
    style.theme_use('clam')

    layers=['*Button', '*Text', '*Label', '*Entry']
    for i in layers: 
            window.option_add(f'{i}.foreground', text_color)
            window.option_add(f'{i}.background', button_backg_color)

#Applying styles via nested dicts. Clean, sweet, warm... :D
    background='#262624'
    foreground='#E9E9E9'
    fieldbackground='#262624'
    dictionary={
        'Treeview':
        {
            'foreground':foreground,
            'background':background,
            'fieldbackground':fieldbackground,
            'font':('Segoe UI', 12)
        },
        'Treeview.Heading':
        {
            'foreground':foreground,
            'background':background,
            'fieldbackground':fieldbackground
        }
    }
    
    for widget_names, properties in dictionary.items():
            style.configure(widget_names,**properties) #KWARGS is where magic happens, makes key value pairs form variable. e.g. background='#262624'

    background=('pressed', '!disabled', "#6791C1"), ('active', '#262624')
    foreground=('pressed', '#E9E9E9'), ('active', '#E9E9E9')
    dictionary={
        'Treeview': 
        {
            'foreground':foreground,
            'background':(('selected','#6793C1'),)+background
        },
        'Treeview.Heading':
        {
            'foreground':foreground,
            'background':background,
        }
    }

    for widget_name, properties in dictionary.items():
        style.map(widget_name,**properties)
    
def programInitialize():
    window=tk.Tk(className="cycloMeter")
    tree_view=Treeview(window, height=24)
    window.configure(background=background_color_main)
    window.geometry('1200x800')
    applyStyle(window)
    
    input_boxes=initEntryBoxes(window,["column:","operator:","value:"]) #input boxes
    button_config=initButtonsConfig(tree_view,input_boxes,window)
    
    status_bar, status_bar_frame=initStatusBar(window)
    tree_view.pack()
    initButtons(button_config) #packs clickables
    for i in input_boxes:i.packButtonHelper()
    for i in status_bar_frame,status_bar: i.pack()
    
    window.mainloop()

if __name__ == "__main__":
    programInitialize()
    
    '''TODO:
        -Do .exe
        -Filterization is single dimensional, increase it for multiple columns and filterizations
        -Expand filterization errors
        
    Function readability and description:

        -Add decription for majority of the functions, methods and objects,
        -Add small logic fixes.
    '''